# Generated from src/MGprogramming.g4 by ANTLR 4.7.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3;")
        buf.write("\u00d3\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\3\2\3\2")
        buf.write("\3\2\3\2\6\2)\n\2\r\2\16\2*\3\2\3\2\3\3\3\3\3\3\3\3\3")
        buf.write("\3\3\3\3\3\5\3\66\n\3\3\4\3\4\3\4\3\4\3\4\3\4\7\4>\n\4")
        buf.write("\f\4\16\4A\13\4\3\4\3\4\3\4\3\5\3\5\3\5\3\5\5\5J\n\5\3")
        buf.write("\5\3\5\3\5\3\5\3\5\3\5\3\6\3\6\3\6\3\6\3\6\7\6W\n\6\f")
        buf.write("\6\16\6Z\13\6\3\7\3\7\3\7\3\7\3\7\3\7\3\7\6\7c\n\7\r\7")
        buf.write("\16\7d\3\b\3\b\3\b\3\b\3\b\3\b\3\t\3\t\3\t\3\t\3\t\3\t")
        buf.write("\3\t\3\t\3\t\3\t\3\t\3\t\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3")
        buf.write("\n\3\n\3\n\3\13\3\13\3\13\3\13\3\13\3\13\3\13\3\13\3\f")
        buf.write("\3\f\6\f\u008d\n\f\r\f\16\f\u008e\3\r\3\r\3\r\3\r\3\16")
        buf.write("\3\16\3\16\3\16\5\16\u0099\n\16\3\16\3\16\3\16\3\17\3")
        buf.write("\17\3\17\3\17\3\17\3\17\5\17\u00a4\n\17\3\20\3\20\3\20")
        buf.write("\3\20\7\20\u00aa\n\20\f\20\16\20\u00ad\13\20\3\20\3\20")
        buf.write("\3\21\3\21\7\21\u00b3\n\21\f\21\16\21\u00b6\13\21\3\21")
        buf.write("\3\21\3\22\3\22\3\22\3\22\3\22\3\22\5\22\u00c0\n\22\3")
        buf.write("\22\3\22\3\22\3\22\3\22\3\22\5\22\u00c8\n\22\7\22\u00ca")
        buf.write("\n\22\f\22\16\22\u00cd\13\22\5\22\u00cf\n\22\3\22\3\22")
        buf.write("\3\22\2\2\23\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36 \"")
        buf.write("\2\6\3\2\63\64\3\2\13\17\4\2++\63\63\4\2++\63\64\2\u00e3")
        buf.write("\2(\3\2\2\2\4\65\3\2\2\2\6\67\3\2\2\2\bE\3\2\2\2\nQ\3")
        buf.write("\2\2\2\fb\3\2\2\2\16f\3\2\2\2\20l\3\2\2\2\22x\3\2\2\2")
        buf.write("\24\u0082\3\2\2\2\26\u008c\3\2\2\2\30\u0090\3\2\2\2\32")
        buf.write("\u0094\3\2\2\2\34\u00a3\3\2\2\2\36\u00a5\3\2\2\2 \u00b0")
        buf.write("\3\2\2\2\"\u00b9\3\2\2\2$)\5\6\4\2%)\5\b\5\2&)\5\4\3\2")
        buf.write("\')\5\34\17\2($\3\2\2\2(%\3\2\2\2(&\3\2\2\2(\'\3\2\2\2")
        buf.write(")*\3\2\2\2*(\3\2\2\2*+\3\2\2\2+,\3\2\2\2,-\7\2\2\3-\3")
        buf.write("\3\2\2\2.\66\5\16\b\2/\66\5\20\t\2\60\66\5\22\n\2\61\66")
        buf.write("\5\24\13\2\62\66\5\30\r\2\63\66\5\32\16\2\64\66\5\34\17")
        buf.write("\2\65.\3\2\2\2\65/\3\2\2\2\65\60\3\2\2\2\65\61\3\2\2\2")
        buf.write("\65\62\3\2\2\2\65\63\3\2\2\2\65\64\3\2\2\2\66\5\3\2\2")
        buf.write("\2\678\7\24\2\289\7\64\2\29?\7\25\2\2:>\5\b\5\2;>\5\4")
        buf.write("\3\2<>\5\34\17\2=:\3\2\2\2=;\3\2\2\2=<\3\2\2\2>A\3\2\2")
        buf.write("\2?=\3\2\2\2?@\3\2\2\2@B\3\2\2\2A?\3\2\2\2BC\7\26\2\2")
        buf.write("CD\7\21\2\2D\7\3\2\2\2EF\7!\2\2FG\7\64\2\2GI\7\65\2\2")
        buf.write("HJ\5\n\6\2IH\3\2\2\2IJ\3\2\2\2JK\3\2\2\2KL\7\66\2\2LM")
        buf.write("\7\22\2\2MN\5\f\7\2NO\7\23\2\2OP\7\21\2\2P\t\3\2\2\2Q")
        buf.write("R\7%\2\2RX\7\64\2\2ST\7\3\2\2TU\7%\2\2UW\7\64\2\2VS\3")
        buf.write("\2\2\2WZ\3\2\2\2XV\3\2\2\2XY\3\2\2\2Y\13\3\2\2\2ZX\3\2")
        buf.write("\2\2[c\5\16\b\2\\c\5\20\t\2]c\5\22\n\2^c\5\24\13\2_c\5")
        buf.write("\30\r\2`c\5\32\16\2ac\5\34\17\2b[\3\2\2\2b\\\3\2\2\2b")
        buf.write("]\3\2\2\2b^\3\2\2\2b_\3\2\2\2b`\3\2\2\2ba\3\2\2\2cd\3")
        buf.write("\2\2\2db\3\2\2\2de\3\2\2\2e\r\3\2\2\2fg\7%\2\2gh\7\64")
        buf.write("\2\2hi\7\4\2\2ij\t\2\2\2jk\7\21\2\2k\17\3\2\2\2lm\7\34")
        buf.write("\2\2mn\7\64\2\2no\7\35\2\2op\7\63\2\2pq\7\36\2\2qr\7\63")
        buf.write("\2\2rs\7\37\2\2st\7\63\2\2tu\7\65\2\2uv\5\26\f\2vw\7\66")
        buf.write("\2\2w\21\3\2\2\2xy\7 \2\2yz\7\65\2\2z{\7\64\2\2{|\t\3")
        buf.write("\2\2|}\t\4\2\2}~\7\66\2\2~\177\7\27\2\2\177\u0080\5\26")
        buf.write("\f\2\u0080\u0081\7\30\2\2\u0081\23\3\2\2\2\u0082\u0083")
        buf.write("\7\31\2\2\u0083\u0084\7\65\2\2\u0084\u0085\7\64\2\2\u0085")
        buf.write("\u0086\7\66\2\2\u0086\u0087\7\27\2\2\u0087\u0088\5\26")
        buf.write("\f\2\u0088\u0089\7\30\2\2\u0089\25\3\2\2\2\u008a\u008d")
        buf.write("\5\4\3\2\u008b\u008d\5\32\16\2\u008c\u008a\3\2\2\2\u008c")
        buf.write("\u008b\3\2\2\2\u008d\u008e\3\2\2\2\u008e\u008c\3\2\2\2")
        buf.write("\u008e\u008f\3\2\2\2\u008f\27\3\2\2\2\u0090\u0091\7\"")
        buf.write("\2\2\u0091\u0092\t\5\2\2\u0092\u0093\7\21\2\2\u0093\31")
        buf.write("\3\2\2\2\u0094\u0095\7!\2\2\u0095\u0096\7\64\2\2\u0096")
        buf.write("\u0098\7\65\2\2\u0097\u0099\5\n\6\2\u0098\u0097\3\2\2")
        buf.write("\2\u0098\u0099\3\2\2\2\u0099\u009a\3\2\2\2\u009a\u009b")
        buf.write("\7\66\2\2\u009b\u009c\7\21\2\2\u009c\33\3\2\2\2\u009d")
        buf.write("\u009e\7\60\2\2\u009e\u009f\7+\2\2\u009f\u00a4\7\21\2")
        buf.write("\2\u00a0\u00a1\7\61\2\2\u00a1\u00a2\7+\2\2\u00a2\u00a4")
        buf.write("\7\62\2\2\u00a3\u009d\3\2\2\2\u00a3\u00a0\3\2\2\2\u00a4")
        buf.write("\35\3\2\2\2\u00a5\u00a6\7\67\2\2\u00a6\u00ab\t\4\2\2\u00a7")
        buf.write("\u00a8\7\3\2\2\u00a8\u00aa\t\4\2\2\u00a9\u00a7\3\2\2\2")
        buf.write("\u00aa\u00ad\3\2\2\2\u00ab\u00a9\3\2\2\2\u00ab\u00ac\3")
        buf.write("\2\2\2\u00ac\u00ae\3\2\2\2\u00ad\u00ab\3\2\2\2\u00ae\u00af")
        buf.write("\78\2\2\u00af\37\3\2\2\2\u00b0\u00b4\7\67\2\2\u00b1\u00b3")
        buf.write("\5\36\20\2\u00b2\u00b1\3\2\2\2\u00b3\u00b6\3\2\2\2\u00b4")
        buf.write("\u00b2\3\2\2\2\u00b4\u00b5\3\2\2\2\u00b5\u00b7\3\2\2\2")
        buf.write("\u00b6\u00b4\3\2\2\2\u00b7\u00b8\78\2\2\u00b8!\3\2\2\2")
        buf.write("\u00b9\u00ce\79\2\2\u00ba\u00bb\7\64\2\2\u00bb\u00bf\7")
        buf.write("\b\2\2\u00bc\u00c0\7+\2\2\u00bd\u00c0\7\63\2\2\u00be\u00c0")
        buf.write("\5\36\20\2\u00bf\u00bc\3\2\2\2\u00bf\u00bd\3\2\2\2\u00bf")
        buf.write("\u00be\3\2\2\2\u00c0\u00cb\3\2\2\2\u00c1\u00c2\7\3\2\2")
        buf.write("\u00c2\u00c3\7\64\2\2\u00c3\u00c7\7\b\2\2\u00c4\u00c8")
        buf.write("\7+\2\2\u00c5\u00c8\7\63\2\2\u00c6\u00c8\5\36\20\2\u00c7")
        buf.write("\u00c4\3\2\2\2\u00c7\u00c5\3\2\2\2\u00c7\u00c6\3\2\2\2")
        buf.write("\u00c8\u00ca\3\2\2\2\u00c9\u00c1\3\2\2\2\u00ca\u00cd\3")
        buf.write("\2\2\2\u00cb\u00c9\3\2\2\2\u00cb\u00cc\3\2\2\2\u00cc\u00cf")
        buf.write("\3\2\2\2\u00cd\u00cb\3\2\2\2\u00ce\u00ba\3\2\2\2\u00ce")
        buf.write("\u00cf\3\2\2\2\u00cf\u00d0\3\2\2\2\u00d0\u00d1\7:\2\2")
        buf.write("\u00d1#\3\2\2\2\25(*\65=?IXbd\u008c\u008e\u0098\u00a3")
        buf.write("\u00ab\u00b4\u00bf\u00c7\u00cb\u00ce")
        return buf.getvalue()


class MGprogrammingParser ( Parser ):

    grammarFileName = "MGprogramming.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "','", "'todorhoiloh'", "'+'", "'-'", 
                     "'*'", "':'", "'^'", "'|'", "'>'", "'<'", "'>='", "'<='", 
                     "'='", "'=/='", "'\n'", "'ehleh'", "'duusgah'", "'angi'", 
                     "'ehleh_angi'", "'duusgah_angi'", "'ehleh_davtalt'", 
                     "'duusgah_davtalt'", "'zuur'", "'urgeljleh'", "'zavsar'", 
                     "'d'", "'aas'", "'tuld'", "'nii tuld'", "'hervee'", 
                     "'ner'", "'butsah'", "'hevleh'", "'orolt'", "<INVALID>", 
                     "'buhel'", "'urt'", "'butarhai'", "'ih_butarhai'", 
                     "'temdegt'", "'mor'", "'tiim_ugui'", "'jagsaalt'", 
                     "'bagts'", "'buleg'", "'>>'", "'>>>'", "'<<<'", "<INVALID>", 
                     "<INVALID>", "'('", "')'", "'['", "']'", "'{'", "'}'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "ASSIGN_VALUE", "PLUS", 
                      "MINUS", "MULTIPLY", "DIVIDE", "POWER", "MODULO", 
                      "GREATER_THAN", "LESSER_THAN", "GREATER_OR_EQUAL", 
                      "LESSER_OR_EQUAL", "EQUAL", "NOT_EQUAL", "NEW_LINE", 
                      "START_FUNCTION", "END_FUNCTION", "CLASS_DEF", "START_CLASS", 
                      "END_CLASS", "START_LOOP", "END_LOOP", "WHILE", "CONTINUE", 
                      "BREAK", "FOR", "FOR_FROM", "FOR_TO", "FOR_JUMP", 
                      "IF", "FUNCT_NAME", "RETURN", "PRINT", "INPUT", "VAR_TYPE", 
                      "INT", "LONG", "FLOAT", "DOUBLE", "CHAR", "STRING", 
                      "BOOLEAN", "LIST", "SET", "DICT", "COMMENT", "START_LONG_COMMENT", 
                      "END_LONG_COMMENT", "NUMBER", "VARIABLE", "OPEN_BRACKET", 
                      "CLOSE_BRACKET", "OPEN_LIST_BRACKET", "CLOSE_LIST_BRACKET", 
                      "DICT_OPEN_BRACKET", "DICT_CLOSE_BRACKET", "WS" ]

    RULE_program = 0
    RULE_statement = 1
    RULE_class_def = 2
    RULE_function_def = 3
    RULE_args = 4
    RULE_function_body = 5
    RULE_assign = 6
    RULE_for_loop = 7
    RULE_if_stmt = 8
    RULE_while_loop = 9
    RULE_loop_body = 10
    RULE_return_stmt = 11
    RULE_function_call = 12
    RULE_comment = 13
    RULE_array = 14
    RULE_table = 15
    RULE_dictionary = 16

    ruleNames =  [ "program", "statement", "class_def", "function_def", 
                   "args", "function_body", "assign", "for_loop", "if_stmt", 
                   "while_loop", "loop_body", "return_stmt", "function_call", 
                   "comment", "array", "table", "dictionary" ]

    EOF = Token.EOF
    T__0=1
    ASSIGN_VALUE=2
    PLUS=3
    MINUS=4
    MULTIPLY=5
    DIVIDE=6
    POWER=7
    MODULO=8
    GREATER_THAN=9
    LESSER_THAN=10
    GREATER_OR_EQUAL=11
    LESSER_OR_EQUAL=12
    EQUAL=13
    NOT_EQUAL=14
    NEW_LINE=15
    START_FUNCTION=16
    END_FUNCTION=17
    CLASS_DEF=18
    START_CLASS=19
    END_CLASS=20
    START_LOOP=21
    END_LOOP=22
    WHILE=23
    CONTINUE=24
    BREAK=25
    FOR=26
    FOR_FROM=27
    FOR_TO=28
    FOR_JUMP=29
    IF=30
    FUNCT_NAME=31
    RETURN=32
    PRINT=33
    INPUT=34
    VAR_TYPE=35
    INT=36
    LONG=37
    FLOAT=38
    DOUBLE=39
    CHAR=40
    STRING=41
    BOOLEAN=42
    LIST=43
    SET=44
    DICT=45
    COMMENT=46
    START_LONG_COMMENT=47
    END_LONG_COMMENT=48
    NUMBER=49
    VARIABLE=50
    OPEN_BRACKET=51
    CLOSE_BRACKET=52
    OPEN_LIST_BRACKET=53
    CLOSE_LIST_BRACKET=54
    DICT_OPEN_BRACKET=55
    DICT_CLOSE_BRACKET=56
    WS=57

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ProgramContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(MGprogrammingParser.EOF, 0)

        def class_def(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MGprogrammingParser.Class_defContext)
            else:
                return self.getTypedRuleContext(MGprogrammingParser.Class_defContext,i)


        def function_def(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MGprogrammingParser.Function_defContext)
            else:
                return self.getTypedRuleContext(MGprogrammingParser.Function_defContext,i)


        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MGprogrammingParser.StatementContext)
            else:
                return self.getTypedRuleContext(MGprogrammingParser.StatementContext,i)


        def comment(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MGprogrammingParser.CommentContext)
            else:
                return self.getTypedRuleContext(MGprogrammingParser.CommentContext,i)


        def getRuleIndex(self):
            return MGprogrammingParser.RULE_program

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProgram" ):
                listener.enterProgram(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProgram" ):
                listener.exitProgram(self)




    def program(self):

        localctx = MGprogrammingParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_program)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 38 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 38
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,0,self._ctx)
                if la_ == 1:
                    self.state = 34
                    self.class_def()
                    pass

                elif la_ == 2:
                    self.state = 35
                    self.function_def()
                    pass

                elif la_ == 3:
                    self.state = 36
                    self.statement()
                    pass

                elif la_ == 4:
                    self.state = 37
                    self.comment()
                    pass


                self.state = 40 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << MGprogrammingParser.CLASS_DEF) | (1 << MGprogrammingParser.WHILE) | (1 << MGprogrammingParser.FOR) | (1 << MGprogrammingParser.IF) | (1 << MGprogrammingParser.FUNCT_NAME) | (1 << MGprogrammingParser.RETURN) | (1 << MGprogrammingParser.VAR_TYPE) | (1 << MGprogrammingParser.COMMENT) | (1 << MGprogrammingParser.START_LONG_COMMENT))) != 0)):
                    break

            self.state = 42
            self.match(MGprogrammingParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assign(self):
            return self.getTypedRuleContext(MGprogrammingParser.AssignContext,0)


        def for_loop(self):
            return self.getTypedRuleContext(MGprogrammingParser.For_loopContext,0)


        def if_stmt(self):
            return self.getTypedRuleContext(MGprogrammingParser.If_stmtContext,0)


        def while_loop(self):
            return self.getTypedRuleContext(MGprogrammingParser.While_loopContext,0)


        def return_stmt(self):
            return self.getTypedRuleContext(MGprogrammingParser.Return_stmtContext,0)


        def function_call(self):
            return self.getTypedRuleContext(MGprogrammingParser.Function_callContext,0)


        def comment(self):
            return self.getTypedRuleContext(MGprogrammingParser.CommentContext,0)


        def getRuleIndex(self):
            return MGprogrammingParser.RULE_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatement" ):
                listener.enterStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatement" ):
                listener.exitStatement(self)




    def statement(self):

        localctx = MGprogrammingParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_statement)
        try:
            self.state = 51
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [MGprogrammingParser.VAR_TYPE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 44
                self.assign()
                pass
            elif token in [MGprogrammingParser.FOR]:
                self.enterOuterAlt(localctx, 2)
                self.state = 45
                self.for_loop()
                pass
            elif token in [MGprogrammingParser.IF]:
                self.enterOuterAlt(localctx, 3)
                self.state = 46
                self.if_stmt()
                pass
            elif token in [MGprogrammingParser.WHILE]:
                self.enterOuterAlt(localctx, 4)
                self.state = 47
                self.while_loop()
                pass
            elif token in [MGprogrammingParser.RETURN]:
                self.enterOuterAlt(localctx, 5)
                self.state = 48
                self.return_stmt()
                pass
            elif token in [MGprogrammingParser.FUNCT_NAME]:
                self.enterOuterAlt(localctx, 6)
                self.state = 49
                self.function_call()
                pass
            elif token in [MGprogrammingParser.COMMENT, MGprogrammingParser.START_LONG_COMMENT]:
                self.enterOuterAlt(localctx, 7)
                self.state = 50
                self.comment()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Class_defContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CLASS_DEF(self):
            return self.getToken(MGprogrammingParser.CLASS_DEF, 0)

        def VARIABLE(self):
            return self.getToken(MGprogrammingParser.VARIABLE, 0)

        def START_CLASS(self):
            return self.getToken(MGprogrammingParser.START_CLASS, 0)

        def END_CLASS(self):
            return self.getToken(MGprogrammingParser.END_CLASS, 0)

        def NEW_LINE(self):
            return self.getToken(MGprogrammingParser.NEW_LINE, 0)

        def function_def(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MGprogrammingParser.Function_defContext)
            else:
                return self.getTypedRuleContext(MGprogrammingParser.Function_defContext,i)


        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MGprogrammingParser.StatementContext)
            else:
                return self.getTypedRuleContext(MGprogrammingParser.StatementContext,i)


        def comment(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MGprogrammingParser.CommentContext)
            else:
                return self.getTypedRuleContext(MGprogrammingParser.CommentContext,i)


        def getRuleIndex(self):
            return MGprogrammingParser.RULE_class_def

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClass_def" ):
                listener.enterClass_def(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClass_def" ):
                listener.exitClass_def(self)




    def class_def(self):

        localctx = MGprogrammingParser.Class_defContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_class_def)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 53
            self.match(MGprogrammingParser.CLASS_DEF)
            self.state = 54
            self.match(MGprogrammingParser.VARIABLE)
            self.state = 55
            self.match(MGprogrammingParser.START_CLASS)
            self.state = 61
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << MGprogrammingParser.WHILE) | (1 << MGprogrammingParser.FOR) | (1 << MGprogrammingParser.IF) | (1 << MGprogrammingParser.FUNCT_NAME) | (1 << MGprogrammingParser.RETURN) | (1 << MGprogrammingParser.VAR_TYPE) | (1 << MGprogrammingParser.COMMENT) | (1 << MGprogrammingParser.START_LONG_COMMENT))) != 0):
                self.state = 59
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
                if la_ == 1:
                    self.state = 56
                    self.function_def()
                    pass

                elif la_ == 2:
                    self.state = 57
                    self.statement()
                    pass

                elif la_ == 3:
                    self.state = 58
                    self.comment()
                    pass


                self.state = 63
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 64
            self.match(MGprogrammingParser.END_CLASS)
            self.state = 65
            self.match(MGprogrammingParser.NEW_LINE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Function_defContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FUNCT_NAME(self):
            return self.getToken(MGprogrammingParser.FUNCT_NAME, 0)

        def VARIABLE(self):
            return self.getToken(MGprogrammingParser.VARIABLE, 0)

        def OPEN_BRACKET(self):
            return self.getToken(MGprogrammingParser.OPEN_BRACKET, 0)

        def CLOSE_BRACKET(self):
            return self.getToken(MGprogrammingParser.CLOSE_BRACKET, 0)

        def START_FUNCTION(self):
            return self.getToken(MGprogrammingParser.START_FUNCTION, 0)

        def function_body(self):
            return self.getTypedRuleContext(MGprogrammingParser.Function_bodyContext,0)


        def END_FUNCTION(self):
            return self.getToken(MGprogrammingParser.END_FUNCTION, 0)

        def NEW_LINE(self):
            return self.getToken(MGprogrammingParser.NEW_LINE, 0)

        def args(self):
            return self.getTypedRuleContext(MGprogrammingParser.ArgsContext,0)


        def getRuleIndex(self):
            return MGprogrammingParser.RULE_function_def

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunction_def" ):
                listener.enterFunction_def(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunction_def" ):
                listener.exitFunction_def(self)




    def function_def(self):

        localctx = MGprogrammingParser.Function_defContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_function_def)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 67
            self.match(MGprogrammingParser.FUNCT_NAME)
            self.state = 68
            self.match(MGprogrammingParser.VARIABLE)
            self.state = 69
            self.match(MGprogrammingParser.OPEN_BRACKET)
            self.state = 71
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==MGprogrammingParser.VAR_TYPE:
                self.state = 70
                self.args()


            self.state = 73
            self.match(MGprogrammingParser.CLOSE_BRACKET)
            self.state = 74
            self.match(MGprogrammingParser.START_FUNCTION)
            self.state = 75
            self.function_body()
            self.state = 76
            self.match(MGprogrammingParser.END_FUNCTION)
            self.state = 77
            self.match(MGprogrammingParser.NEW_LINE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArgsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VAR_TYPE(self, i:int=None):
            if i is None:
                return self.getTokens(MGprogrammingParser.VAR_TYPE)
            else:
                return self.getToken(MGprogrammingParser.VAR_TYPE, i)

        def VARIABLE(self, i:int=None):
            if i is None:
                return self.getTokens(MGprogrammingParser.VARIABLE)
            else:
                return self.getToken(MGprogrammingParser.VARIABLE, i)

        def getRuleIndex(self):
            return MGprogrammingParser.RULE_args

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArgs" ):
                listener.enterArgs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArgs" ):
                listener.exitArgs(self)




    def args(self):

        localctx = MGprogrammingParser.ArgsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_args)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 79
            self.match(MGprogrammingParser.VAR_TYPE)
            self.state = 80
            self.match(MGprogrammingParser.VARIABLE)
            self.state = 86
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==MGprogrammingParser.T__0:
                self.state = 81
                self.match(MGprogrammingParser.T__0)
                self.state = 82
                self.match(MGprogrammingParser.VAR_TYPE)
                self.state = 83
                self.match(MGprogrammingParser.VARIABLE)
                self.state = 88
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Function_bodyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assign(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MGprogrammingParser.AssignContext)
            else:
                return self.getTypedRuleContext(MGprogrammingParser.AssignContext,i)


        def for_loop(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MGprogrammingParser.For_loopContext)
            else:
                return self.getTypedRuleContext(MGprogrammingParser.For_loopContext,i)


        def if_stmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MGprogrammingParser.If_stmtContext)
            else:
                return self.getTypedRuleContext(MGprogrammingParser.If_stmtContext,i)


        def while_loop(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MGprogrammingParser.While_loopContext)
            else:
                return self.getTypedRuleContext(MGprogrammingParser.While_loopContext,i)


        def return_stmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MGprogrammingParser.Return_stmtContext)
            else:
                return self.getTypedRuleContext(MGprogrammingParser.Return_stmtContext,i)


        def function_call(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MGprogrammingParser.Function_callContext)
            else:
                return self.getTypedRuleContext(MGprogrammingParser.Function_callContext,i)


        def comment(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MGprogrammingParser.CommentContext)
            else:
                return self.getTypedRuleContext(MGprogrammingParser.CommentContext,i)


        def getRuleIndex(self):
            return MGprogrammingParser.RULE_function_body

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunction_body" ):
                listener.enterFunction_body(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunction_body" ):
                listener.exitFunction_body(self)




    def function_body(self):

        localctx = MGprogrammingParser.Function_bodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_function_body)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 96 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 96
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [MGprogrammingParser.VAR_TYPE]:
                    self.state = 89
                    self.assign()
                    pass
                elif token in [MGprogrammingParser.FOR]:
                    self.state = 90
                    self.for_loop()
                    pass
                elif token in [MGprogrammingParser.IF]:
                    self.state = 91
                    self.if_stmt()
                    pass
                elif token in [MGprogrammingParser.WHILE]:
                    self.state = 92
                    self.while_loop()
                    pass
                elif token in [MGprogrammingParser.RETURN]:
                    self.state = 93
                    self.return_stmt()
                    pass
                elif token in [MGprogrammingParser.FUNCT_NAME]:
                    self.state = 94
                    self.function_call()
                    pass
                elif token in [MGprogrammingParser.COMMENT, MGprogrammingParser.START_LONG_COMMENT]:
                    self.state = 95
                    self.comment()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 98 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << MGprogrammingParser.WHILE) | (1 << MGprogrammingParser.FOR) | (1 << MGprogrammingParser.IF) | (1 << MGprogrammingParser.FUNCT_NAME) | (1 << MGprogrammingParser.RETURN) | (1 << MGprogrammingParser.VAR_TYPE) | (1 << MGprogrammingParser.COMMENT) | (1 << MGprogrammingParser.START_LONG_COMMENT))) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssignContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VAR_TYPE(self):
            return self.getToken(MGprogrammingParser.VAR_TYPE, 0)

        def VARIABLE(self, i:int=None):
            if i is None:
                return self.getTokens(MGprogrammingParser.VARIABLE)
            else:
                return self.getToken(MGprogrammingParser.VARIABLE, i)

        def ASSIGN_VALUE(self):
            return self.getToken(MGprogrammingParser.ASSIGN_VALUE, 0)

        def NEW_LINE(self):
            return self.getToken(MGprogrammingParser.NEW_LINE, 0)

        def NUMBER(self):
            return self.getToken(MGprogrammingParser.NUMBER, 0)

        def getRuleIndex(self):
            return MGprogrammingParser.RULE_assign

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign" ):
                listener.enterAssign(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign" ):
                listener.exitAssign(self)




    def assign(self):

        localctx = MGprogrammingParser.AssignContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_assign)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 100
            self.match(MGprogrammingParser.VAR_TYPE)
            self.state = 101
            self.match(MGprogrammingParser.VARIABLE)
            self.state = 102
            self.match(MGprogrammingParser.ASSIGN_VALUE)
            self.state = 103
            _la = self._input.LA(1)
            if not(_la==MGprogrammingParser.NUMBER or _la==MGprogrammingParser.VARIABLE):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 104
            self.match(MGprogrammingParser.NEW_LINE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class For_loopContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FOR(self):
            return self.getToken(MGprogrammingParser.FOR, 0)

        def VARIABLE(self):
            return self.getToken(MGprogrammingParser.VARIABLE, 0)

        def FOR_FROM(self):
            return self.getToken(MGprogrammingParser.FOR_FROM, 0)

        def NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(MGprogrammingParser.NUMBER)
            else:
                return self.getToken(MGprogrammingParser.NUMBER, i)

        def FOR_TO(self):
            return self.getToken(MGprogrammingParser.FOR_TO, 0)

        def FOR_JUMP(self):
            return self.getToken(MGprogrammingParser.FOR_JUMP, 0)

        def OPEN_BRACKET(self):
            return self.getToken(MGprogrammingParser.OPEN_BRACKET, 0)

        def loop_body(self):
            return self.getTypedRuleContext(MGprogrammingParser.Loop_bodyContext,0)


        def CLOSE_BRACKET(self):
            return self.getToken(MGprogrammingParser.CLOSE_BRACKET, 0)

        def getRuleIndex(self):
            return MGprogrammingParser.RULE_for_loop

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFor_loop" ):
                listener.enterFor_loop(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFor_loop" ):
                listener.exitFor_loop(self)




    def for_loop(self):

        localctx = MGprogrammingParser.For_loopContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_for_loop)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 106
            self.match(MGprogrammingParser.FOR)
            self.state = 107
            self.match(MGprogrammingParser.VARIABLE)
            self.state = 108
            self.match(MGprogrammingParser.FOR_FROM)
            self.state = 109
            self.match(MGprogrammingParser.NUMBER)
            self.state = 110
            self.match(MGprogrammingParser.FOR_TO)
            self.state = 111
            self.match(MGprogrammingParser.NUMBER)
            self.state = 112
            self.match(MGprogrammingParser.FOR_JUMP)
            self.state = 113
            self.match(MGprogrammingParser.NUMBER)
            self.state = 114
            self.match(MGprogrammingParser.OPEN_BRACKET)
            self.state = 115
            self.loop_body()
            self.state = 116
            self.match(MGprogrammingParser.CLOSE_BRACKET)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class If_stmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(MGprogrammingParser.IF, 0)

        def OPEN_BRACKET(self):
            return self.getToken(MGprogrammingParser.OPEN_BRACKET, 0)

        def VARIABLE(self):
            return self.getToken(MGprogrammingParser.VARIABLE, 0)

        def CLOSE_BRACKET(self):
            return self.getToken(MGprogrammingParser.CLOSE_BRACKET, 0)

        def START_LOOP(self):
            return self.getToken(MGprogrammingParser.START_LOOP, 0)

        def loop_body(self):
            return self.getTypedRuleContext(MGprogrammingParser.Loop_bodyContext,0)


        def END_LOOP(self):
            return self.getToken(MGprogrammingParser.END_LOOP, 0)

        def EQUAL(self):
            return self.getToken(MGprogrammingParser.EQUAL, 0)

        def GREATER_THAN(self):
            return self.getToken(MGprogrammingParser.GREATER_THAN, 0)

        def LESSER_THAN(self):
            return self.getToken(MGprogrammingParser.LESSER_THAN, 0)

        def GREATER_OR_EQUAL(self):
            return self.getToken(MGprogrammingParser.GREATER_OR_EQUAL, 0)

        def LESSER_OR_EQUAL(self):
            return self.getToken(MGprogrammingParser.LESSER_OR_EQUAL, 0)

        def NUMBER(self):
            return self.getToken(MGprogrammingParser.NUMBER, 0)

        def STRING(self):
            return self.getToken(MGprogrammingParser.STRING, 0)

        def getRuleIndex(self):
            return MGprogrammingParser.RULE_if_stmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIf_stmt" ):
                listener.enterIf_stmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIf_stmt" ):
                listener.exitIf_stmt(self)




    def if_stmt(self):

        localctx = MGprogrammingParser.If_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_if_stmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 118
            self.match(MGprogrammingParser.IF)
            self.state = 119
            self.match(MGprogrammingParser.OPEN_BRACKET)
            self.state = 120
            self.match(MGprogrammingParser.VARIABLE)
            self.state = 121
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << MGprogrammingParser.GREATER_THAN) | (1 << MGprogrammingParser.LESSER_THAN) | (1 << MGprogrammingParser.GREATER_OR_EQUAL) | (1 << MGprogrammingParser.LESSER_OR_EQUAL) | (1 << MGprogrammingParser.EQUAL))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 122
            _la = self._input.LA(1)
            if not(_la==MGprogrammingParser.STRING or _la==MGprogrammingParser.NUMBER):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 123
            self.match(MGprogrammingParser.CLOSE_BRACKET)
            self.state = 124
            self.match(MGprogrammingParser.START_LOOP)
            self.state = 125
            self.loop_body()
            self.state = 126
            self.match(MGprogrammingParser.END_LOOP)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class While_loopContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHILE(self):
            return self.getToken(MGprogrammingParser.WHILE, 0)

        def OPEN_BRACKET(self):
            return self.getToken(MGprogrammingParser.OPEN_BRACKET, 0)

        def VARIABLE(self):
            return self.getToken(MGprogrammingParser.VARIABLE, 0)

        def CLOSE_BRACKET(self):
            return self.getToken(MGprogrammingParser.CLOSE_BRACKET, 0)

        def START_LOOP(self):
            return self.getToken(MGprogrammingParser.START_LOOP, 0)

        def loop_body(self):
            return self.getTypedRuleContext(MGprogrammingParser.Loop_bodyContext,0)


        def END_LOOP(self):
            return self.getToken(MGprogrammingParser.END_LOOP, 0)

        def getRuleIndex(self):
            return MGprogrammingParser.RULE_while_loop

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhile_loop" ):
                listener.enterWhile_loop(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhile_loop" ):
                listener.exitWhile_loop(self)




    def while_loop(self):

        localctx = MGprogrammingParser.While_loopContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_while_loop)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 128
            self.match(MGprogrammingParser.WHILE)
            self.state = 129
            self.match(MGprogrammingParser.OPEN_BRACKET)
            self.state = 130
            self.match(MGprogrammingParser.VARIABLE)
            self.state = 131
            self.match(MGprogrammingParser.CLOSE_BRACKET)
            self.state = 132
            self.match(MGprogrammingParser.START_LOOP)
            self.state = 133
            self.loop_body()
            self.state = 134
            self.match(MGprogrammingParser.END_LOOP)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Loop_bodyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MGprogrammingParser.StatementContext)
            else:
                return self.getTypedRuleContext(MGprogrammingParser.StatementContext,i)


        def function_call(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MGprogrammingParser.Function_callContext)
            else:
                return self.getTypedRuleContext(MGprogrammingParser.Function_callContext,i)


        def getRuleIndex(self):
            return MGprogrammingParser.RULE_loop_body

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoop_body" ):
                listener.enterLoop_body(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoop_body" ):
                listener.exitLoop_body(self)




    def loop_body(self):

        localctx = MGprogrammingParser.Loop_bodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_loop_body)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 138 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 138
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,9,self._ctx)
                if la_ == 1:
                    self.state = 136
                    self.statement()
                    pass

                elif la_ == 2:
                    self.state = 137
                    self.function_call()
                    pass


                self.state = 140 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << MGprogrammingParser.WHILE) | (1 << MGprogrammingParser.FOR) | (1 << MGprogrammingParser.IF) | (1 << MGprogrammingParser.FUNCT_NAME) | (1 << MGprogrammingParser.RETURN) | (1 << MGprogrammingParser.VAR_TYPE) | (1 << MGprogrammingParser.COMMENT) | (1 << MGprogrammingParser.START_LONG_COMMENT))) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Return_stmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RETURN(self):
            return self.getToken(MGprogrammingParser.RETURN, 0)

        def NEW_LINE(self):
            return self.getToken(MGprogrammingParser.NEW_LINE, 0)

        def VARIABLE(self):
            return self.getToken(MGprogrammingParser.VARIABLE, 0)

        def NUMBER(self):
            return self.getToken(MGprogrammingParser.NUMBER, 0)

        def STRING(self):
            return self.getToken(MGprogrammingParser.STRING, 0)

        def getRuleIndex(self):
            return MGprogrammingParser.RULE_return_stmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReturn_stmt" ):
                listener.enterReturn_stmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReturn_stmt" ):
                listener.exitReturn_stmt(self)




    def return_stmt(self):

        localctx = MGprogrammingParser.Return_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_return_stmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 142
            self.match(MGprogrammingParser.RETURN)
            self.state = 143
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << MGprogrammingParser.STRING) | (1 << MGprogrammingParser.NUMBER) | (1 << MGprogrammingParser.VARIABLE))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 144
            self.match(MGprogrammingParser.NEW_LINE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Function_callContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FUNCT_NAME(self):
            return self.getToken(MGprogrammingParser.FUNCT_NAME, 0)

        def VARIABLE(self):
            return self.getToken(MGprogrammingParser.VARIABLE, 0)

        def OPEN_BRACKET(self):
            return self.getToken(MGprogrammingParser.OPEN_BRACKET, 0)

        def CLOSE_BRACKET(self):
            return self.getToken(MGprogrammingParser.CLOSE_BRACKET, 0)

        def NEW_LINE(self):
            return self.getToken(MGprogrammingParser.NEW_LINE, 0)

        def args(self):
            return self.getTypedRuleContext(MGprogrammingParser.ArgsContext,0)


        def getRuleIndex(self):
            return MGprogrammingParser.RULE_function_call

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunction_call" ):
                listener.enterFunction_call(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunction_call" ):
                listener.exitFunction_call(self)




    def function_call(self):

        localctx = MGprogrammingParser.Function_callContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_function_call)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 146
            self.match(MGprogrammingParser.FUNCT_NAME)
            self.state = 147
            self.match(MGprogrammingParser.VARIABLE)
            self.state = 148
            self.match(MGprogrammingParser.OPEN_BRACKET)
            self.state = 150
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==MGprogrammingParser.VAR_TYPE:
                self.state = 149
                self.args()


            self.state = 152
            self.match(MGprogrammingParser.CLOSE_BRACKET)
            self.state = 153
            self.match(MGprogrammingParser.NEW_LINE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CommentContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMMENT(self):
            return self.getToken(MGprogrammingParser.COMMENT, 0)

        def STRING(self):
            return self.getToken(MGprogrammingParser.STRING, 0)

        def NEW_LINE(self):
            return self.getToken(MGprogrammingParser.NEW_LINE, 0)

        def START_LONG_COMMENT(self):
            return self.getToken(MGprogrammingParser.START_LONG_COMMENT, 0)

        def END_LONG_COMMENT(self):
            return self.getToken(MGprogrammingParser.END_LONG_COMMENT, 0)

        def getRuleIndex(self):
            return MGprogrammingParser.RULE_comment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComment" ):
                listener.enterComment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComment" ):
                listener.exitComment(self)




    def comment(self):

        localctx = MGprogrammingParser.CommentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_comment)
        try:
            self.state = 161
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [MGprogrammingParser.COMMENT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 155
                self.match(MGprogrammingParser.COMMENT)
                self.state = 156
                self.match(MGprogrammingParser.STRING)
                self.state = 157
                self.match(MGprogrammingParser.NEW_LINE)
                pass
            elif token in [MGprogrammingParser.START_LONG_COMMENT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 158
                self.match(MGprogrammingParser.START_LONG_COMMENT)
                self.state = 159
                self.match(MGprogrammingParser.STRING)
                self.state = 160
                self.match(MGprogrammingParser.END_LONG_COMMENT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArrayContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_LIST_BRACKET(self):
            return self.getToken(MGprogrammingParser.OPEN_LIST_BRACKET, 0)

        def CLOSE_LIST_BRACKET(self):
            return self.getToken(MGprogrammingParser.CLOSE_LIST_BRACKET, 0)

        def STRING(self, i:int=None):
            if i is None:
                return self.getTokens(MGprogrammingParser.STRING)
            else:
                return self.getToken(MGprogrammingParser.STRING, i)

        def NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(MGprogrammingParser.NUMBER)
            else:
                return self.getToken(MGprogrammingParser.NUMBER, i)

        def getRuleIndex(self):
            return MGprogrammingParser.RULE_array

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArray" ):
                listener.enterArray(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArray" ):
                listener.exitArray(self)




    def array(self):

        localctx = MGprogrammingParser.ArrayContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_array)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 163
            self.match(MGprogrammingParser.OPEN_LIST_BRACKET)
            self.state = 164
            _la = self._input.LA(1)
            if not(_la==MGprogrammingParser.STRING or _la==MGprogrammingParser.NUMBER):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 169
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==MGprogrammingParser.T__0:
                self.state = 165
                self.match(MGprogrammingParser.T__0)
                self.state = 166
                _la = self._input.LA(1)
                if not(_la==MGprogrammingParser.STRING or _la==MGprogrammingParser.NUMBER):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 171
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 172
            self.match(MGprogrammingParser.CLOSE_LIST_BRACKET)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TableContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_LIST_BRACKET(self):
            return self.getToken(MGprogrammingParser.OPEN_LIST_BRACKET, 0)

        def CLOSE_LIST_BRACKET(self):
            return self.getToken(MGprogrammingParser.CLOSE_LIST_BRACKET, 0)

        def array(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MGprogrammingParser.ArrayContext)
            else:
                return self.getTypedRuleContext(MGprogrammingParser.ArrayContext,i)


        def getRuleIndex(self):
            return MGprogrammingParser.RULE_table

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTable" ):
                listener.enterTable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTable" ):
                listener.exitTable(self)




    def table(self):

        localctx = MGprogrammingParser.TableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_table)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 174
            self.match(MGprogrammingParser.OPEN_LIST_BRACKET)
            self.state = 178
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==MGprogrammingParser.OPEN_LIST_BRACKET:
                self.state = 175
                self.array()
                self.state = 180
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 181
            self.match(MGprogrammingParser.CLOSE_LIST_BRACKET)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DictionaryContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DICT_OPEN_BRACKET(self):
            return self.getToken(MGprogrammingParser.DICT_OPEN_BRACKET, 0)

        def DICT_CLOSE_BRACKET(self):
            return self.getToken(MGprogrammingParser.DICT_CLOSE_BRACKET, 0)

        def VARIABLE(self, i:int=None):
            if i is None:
                return self.getTokens(MGprogrammingParser.VARIABLE)
            else:
                return self.getToken(MGprogrammingParser.VARIABLE, i)

        def DIVIDE(self, i:int=None):
            if i is None:
                return self.getTokens(MGprogrammingParser.DIVIDE)
            else:
                return self.getToken(MGprogrammingParser.DIVIDE, i)

        def STRING(self, i:int=None):
            if i is None:
                return self.getTokens(MGprogrammingParser.STRING)
            else:
                return self.getToken(MGprogrammingParser.STRING, i)

        def NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(MGprogrammingParser.NUMBER)
            else:
                return self.getToken(MGprogrammingParser.NUMBER, i)

        def array(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MGprogrammingParser.ArrayContext)
            else:
                return self.getTypedRuleContext(MGprogrammingParser.ArrayContext,i)


        def getRuleIndex(self):
            return MGprogrammingParser.RULE_dictionary

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDictionary" ):
                listener.enterDictionary(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDictionary" ):
                listener.exitDictionary(self)




    def dictionary(self):

        localctx = MGprogrammingParser.DictionaryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_dictionary)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 183
            self.match(MGprogrammingParser.DICT_OPEN_BRACKET)
            self.state = 204
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==MGprogrammingParser.VARIABLE:
                self.state = 184
                self.match(MGprogrammingParser.VARIABLE)
                self.state = 185
                self.match(MGprogrammingParser.DIVIDE)
                self.state = 189
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [MGprogrammingParser.STRING]:
                    self.state = 186
                    self.match(MGprogrammingParser.STRING)
                    pass
                elif token in [MGprogrammingParser.NUMBER]:
                    self.state = 187
                    self.match(MGprogrammingParser.NUMBER)
                    pass
                elif token in [MGprogrammingParser.OPEN_LIST_BRACKET]:
                    self.state = 188
                    self.array()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 201
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==MGprogrammingParser.T__0:
                    self.state = 191
                    self.match(MGprogrammingParser.T__0)
                    self.state = 192
                    self.match(MGprogrammingParser.VARIABLE)
                    self.state = 193
                    self.match(MGprogrammingParser.DIVIDE)
                    self.state = 197
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [MGprogrammingParser.STRING]:
                        self.state = 194
                        self.match(MGprogrammingParser.STRING)
                        pass
                    elif token in [MGprogrammingParser.NUMBER]:
                        self.state = 195
                        self.match(MGprogrammingParser.NUMBER)
                        pass
                    elif token in [MGprogrammingParser.OPEN_LIST_BRACKET]:
                        self.state = 196
                        self.array()
                        pass
                    else:
                        raise NoViableAltException(self)

                    self.state = 203
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 206
            self.match(MGprogrammingParser.DICT_CLOSE_BRACKET)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





